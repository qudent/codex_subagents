#!/usr/bin/env bash
# wtx — worktree + mux session spawner with shared uv env, pnpm bootstrap, and raw keystroke injection.
# Usage:
#   wtx [NAME] [-c CMD] [--from REF] [--mux auto|tmux|screen] [--no-open]
#       [--dry-run] [--verbose] [--delete-branches] [prune]
#
# Examples:
#   wtx -c 'pytest -q'
#   wtx mytask --from HEAD~2
#   wtx prune --dry-run

set -euo pipefail
IFS=$'\n\t'

# -------- utils --------
need() { command -v "$1" >/dev/null 2>&1; }
die() { printf 'wtx: error: %s\n' "$*" >&2; exit 1; }
logv() { [[ ${VERBOSE:-0} -eq 1 ]] && printf 'wtx: %s\n' "$*" >&2 || true; }

# -------- defaults --------
MUX=${MUX:-auto}                  # auto|tmux|screen
WTX_GIT_DIR_DEFAULT=""
WTX_UV_ENV=${WTX_UV_ENV:-"$HOME/.wtx/uv-shared"}
WTX_MESSAGING_POLICY=${WTX_MESSAGING_POLICY:-parent,children}
WTX_PROMPT=${WTX_PROMPT:-0}
NO_OPEN=${NO_OPEN:-}
DRY_RUN=0
VERBOSE=0
DELETE_BRANCHES=0
CMD=""
FROM_REF=""

POSITIONAL_NAME=""

show_help() {
  cat <<'EOF'
wtx — create or reuse a git worktree + tmux/screen session, print a one-line banner, and optionally send raw keystrokes.

USAGE:
  wtx [NAME] [options]
  wtx prune [--dry-run] [--delete-branches]

OPTIONS:
  NAME                 Optional explicit branch name (e.g. wtx/main-7). If omitted, auto-numbers from current branch.
  -c CMD               Send raw keystrokes to the pane (exactly as typed) and press Enter.
  --from REF           Create branch from REF (default: HEAD).
  --mux MUX            'auto' (default), 'tmux', or 'screen'.
  --no-open            Do not attach/switch; just print attach command.
  --dry-run            Simulate actions (for prune, and minor logging elsewhere).
  --verbose            More logging.
  --delete-branches    (prune) actually delete merged wtx/* branches.
  -h, --help           Show this help.

BANNER (single line, printed in-pane):
  wtx: repo=<repo> branch=<branch> parent=<name|detached@abcd123> from=<ref> actions=[env:..., pnpm:..., session:...]

NOTES:
  • Requires git. Prefers tmux; falls back to screen if tmux missing and screen present.
  • If uv is installed, a shared env is linked (WTX_UV_ENV, default: ~/.wtx/uv-shared).
  • If pnpm & package.json exist, pnpm install runs once per worktree (stamp: .wtx_pnpm_stamp).
EOF
}

# -------- argparse --------
if [[ $# -eq 0 ]]; then :; fi

# detect subcommand 'prune' early (but allow options after it)
SUBCMD=""
for x in "$@"; do
  if [[ "$x" == "prune" ]]; then SUBCMD="prune"; break; fi
done

if [[ -z "$SUBCMD" ]]; then
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c) shift; CMD="${1:-}"; [[ -z "$CMD" ]] && die "-c requires a command"; shift || true; continue ;;
      --from) shift; FROM_REF="${1:-}"; [[ -z "$FROM_REF" ]] && die "--from needs a ref"; shift || true; continue ;;
      --mux) shift; MUX="${1:-}"; shift || true; continue ;;
      --no-open) NO_OPEN=1; shift; continue ;;
      --dry-run) DRY_RUN=1; shift; continue ;;
      --verbose) VERBOSE=1; shift; continue ;;
      --delete-branches) DELETE_BRANCHES=1; shift; continue ;;
      -h|--help) show_help; exit 0 ;;
      --) shift; break ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        if [[ -z "$POSITIONAL_NAME" ]]; then POSITIONAL_NAME="$1"; else die "unexpected positional: $1"; fi
        shift
        ;;
    esac
  done
else
  # consume 'prune' then options
  PRUNE_DRY=0
  shift # remove first occurrence of 'prune'
  # rebuild args without the first 'prune'
  ARGS=()
  seen=0
  for a in "$@"; do
    if [[ "$a" == "prune" && $seen -eq 0 ]]; then seen=1; continue; fi
    ARGS+=("$a")
  done
  set -- "${ARGS[@]}"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) PRUNE_DRY=1; shift; continue ;;
      --delete-branches) DELETE_BRANCHES=1; shift; continue ;;
      --verbose) VERBOSE=1; shift; continue ;;
      -h|--help) show_help; exit 0 ;;
      *) die "unknown prune option: $1" ;;
    esac
  done
fi

# -------- repo context --------
need git || die "git is required"
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || die "not inside a git repo"
GIT_DIR=$(git rev-parse --git-dir)
REPO_BASENAME=$(basename "$REPO_ROOT")
WTX_GIT_DIR=${WTX_GIT_DIR:-"$GIT_DIR/wtx"}
mkdir -p "$WTX_GIT_DIR"/{logs,locks,state} || true
chmod 700 "$WTX_GIT_DIR" || true

# utilities
hash8() {
  if need sha1sum; then printf %s "$1" | sha1sum | cut -c1-8
  else printf %s "$1" | shasum -a 1 | cut -c1-8
  fi
}

# -------- prune subcommand --------
if [[ "$SUBCMD" == "prune" ]]; then
  logv "prune: scanning…"
  WORKTREE_ROOT="$(dirname "$REPO_ROOT")/${REPO_BASENAME}.worktrees"
  # list registered worktrees
  mapfile -t listed < <(git -C "$REPO_ROOT" worktree list --porcelain | awk '/^worktree /{print $2}')
  # existing dirs
  mapfile -t on_disk < <(test -d "$WORKTREE_ROOT" && find "$WORKTREE_ROOT" -mindepth 1 -maxdepth 1 -type d -print || true)

  # sessions (tmux/screen)—best-effort
  tmux_ses=()
  if need tmux; then
    while IFS= read -r s; do tmux_ses+=("$s"); done < <(tmux list-sessions -F '#S' 2>/dev/null || true)
  fi
  screen_ses=()
  if need screen; then
    while IFS= read -r s; do screen_ses+=("$s"); done < <(screen -ls 2>/dev/null | awk '/\t/ {print $1}' | sed 's/^[0-9]*\.//')
  fi

  echo "=== wtx prune (dry-run=$PRUNE_DRY, delete-branches=$DELETE_BRANCHES) ==="
  echo "Worktree root: $WORKTREE_ROOT"
  echo
  # orphan dirs (on disk but not listed)
  declare -A listed_set
  for p in "${listed[@]}"; do listed_set["$p"]=1; done

  echo "Orphan worktree dirs:"
  for d in "${on_disk[@]:-}"; do
    if [[ -z "${listed_set["$d"]:-}" ]]; then
      echo "  rm -rf '$d'"
      if [[ $PRUNE_DRY -eq 0 ]]; then rm -rf -- "$d"; fi
    fi
  done
  echo

  # sessions without dirs (best-effort: trust naming prefix "wtx.")
  echo "Dead sessions to kill:"
  for s in "${tmux_ses[@]}"; do
    [[ "$s" == wtx.* ]] || continue
    # cannot reliably map to path; offer kill of stray sessions on request
    # (leave as info)
    echo "  tmux kill-session -t '$s'   # review manually"
  done
  for s in "${screen_ses[@]}"; do
    [[ "$s" == wtx.* ]] || continue
    echo "  screen -S '$s' -X quit      # review manually"
  done
  echo

  # optional branch deletion (merged)
  if [[ $DELETE_BRANCHES -eq 1 ]]; then
    echo "Deleting merged wtx/* branches:"
    mapfile -t wtx_branches < <(git for-each-ref --format='%(refname:short)' 'refs/heads/wtx/*')
    for b in "${wtx_branches[@]:-}"; do
      if git branch --merged | grep -qx "  $b"; then
        echo "  git branch -d '$b'"
        [[ $PRUNE_DRY -eq 0 ]] && git branch -d "$b" || true
      fi
    done
  else
    echo "Branch deletions skipped (use --delete-branches)."
  fi
  exit 0
fi

# -------- choose mux --------
if [[ "$MUX" == "auto" ]]; then
  if need tmux; then MUX="tmux"
  elif need screen; then MUX="screen"
  else die "need tmux or screen installed"
  fi
fi
logv "mux backend: $MUX"

# -------- branch / parent --------
FROM_REF=${FROM_REF:-HEAD}
PARENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo detached)
PARENT_SHA=$(git rev-parse "$FROM_REF")
PARENT_SHORT=$(git rev-parse --short "$PARENT_SHA")
if [[ "$PARENT_BRANCH" == "HEAD" ]] || [[ "$PARENT_BRANCH" == "detached" ]]; then
  PARENT_BRANCH="detached"
fi

# locking (portable) for autonumbering
auto_name() {
  local parent="$1"
  local lockdir="$WTX_GIT_DIR/locks/${parent}.lockdir"
  while ! mkdir "$lockdir" 2>/dev/null; do sleep 0.05; done
  trap 'rmdir "'"$lockdir"'" 2>/dev/null || true' EXIT
  local existing
  existing=$(git for-each-ref --format='%(refname:short)' "refs/heads/wtx/${parent}-*" \
    | grep -E "^wtx/${parent}-[0-9]+$" \
    | sed -E 's/.*-([0-9]+)$/\1/' | sort -n | tail -1 || true)
  local NN=$(( ${existing:-0} + 1 ))
  printf 'wtx/%s-%d' "$parent" "$NN"
}

BRANCH_NAME="${POSITIONAL_NAME:-$(auto_name "$PARENT_BRANCH")}"
WORKTREE_NAME=$(printf %s "$BRANCH_NAME" | tr '/:' '__')

# ensure branch exists
if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
  logv "creating branch $BRANCH_NAME from $FROM_REF"
  git branch "$BRANCH_NAME" "$FROM_REF" 2>/dev/null || git branch --no-track "$BRANCH_NAME" "$FROM_REF" || true
fi

# description
printf -v desc 'wtx: created_by=wtx\nwtx: parent_branch=%s\nwtx: from_ref=%s' "$PARENT_BRANCH" "$FROM_REF"
git config "branch.$BRANCH_NAME.description" "$desc"

# small state json (atomic)
state="$WTX_GIT_DIR/state/$WORKTREE_NAME.json"
tmp=$(mktemp)
printf '{"created_by":"wtx","parent_branch":"%s","from_ref":"%s"}\n' "$PARENT_BRANCH" "$FROM_REF" >"$tmp"
mv "$tmp" "$state"

# -------- worktree paths --------
WORKTREE_ROOT="$(dirname "$REPO_ROOT")/${REPO_BASENAME}.worktrees"
WT_DIR="$WORKTREE_ROOT/$WORKTREE_NAME"
mkdir -p "$WORKTREE_ROOT"

# repair zombies
if [[ -d "$WT_DIR" ]] && ! git -C "$REPO_ROOT" worktree list --porcelain | grep -q "worktree $WT_DIR"; then
  logv "repairing/pruning zombie worktree dir"
  git -C "$REPO_ROOT" worktree prune || true
fi

# ensure worktree
if ! git -C "$REPO_ROOT" worktree list --porcelain | grep -q "worktree $WT_DIR"; then
  logv "adding worktree $WT_DIR"
  git -C "$REPO_ROOT" worktree add "$WT_DIR" "$BRANCH_NAME"
fi

# -------- shared uv env --------
ENV_STATUS="none"
if need uv; then
  if [[ ! -d "$WTX_UV_ENV" ]]; then
    logv "creating uv env at $WTX_UV_ENV"
    uv venv "$WTX_UV_ENV"
  fi
  ENV_STATUS="linked"
fi

# -------- pnpm bootstrap --------
PNPM_STATUS="none"
if [[ -f "$WT_DIR/package.json" ]] && need pnpm; then
  PNPM_STAMP="$WT_DIR/.wtx_pnpm_stamp"
  if [[ ! -d "$WT_DIR/node_modules" ]] || [[ -f "$WT_DIR/pnpm-lock.yaml" && "$WT_DIR/pnpm-lock.yaml" -nt "$PNPM_STAMP" ]]; then
    logv "running pnpm install"
    ( cd "$WT_DIR" && pnpm install --frozen-lockfile )
    tmp=$(mktemp) && date +%s >"$tmp" && mv "$tmp" "$PNPM_STAMP"
    PNPM_STATUS="installed"
  else
    PNPM_STATUS="skipped"
  fi
fi

# -------- session naming --------
ses_repo=$(printf %s "$REPO_BASENAME" | tr '/:' '__')
ses_branch=$(printf %s "$BRANCH_NAME" | tr '/:' '__')
SES_NAME="wtx.${ses_repo}.${ses_branch}"
REPO_ID=$(hash8 "$REPO_ROOT")

PARENT_LABEL=$([[ "$PARENT_BRANCH" == detached ]] && echo "detached@$PARENT_SHORT" || echo "$PARENT_BRANCH")
ACTIONS="env:${ENV_STATUS}, pnpm:${PNPM_STATUS}, session:created"

# -------- mux: tmux or screen --------
attach_hint() {
  if [[ "$MUX" == "tmux" ]]; then
    echo "Attach with: tmux attach -t '$SES_NAME'"
  else
    echo "Attach with: screen -r '$SES_NAME'"
  fi
}

if [[ "$MUX" == "tmux" ]]; then
  need tmux || die "tmux not found"
  if ! tmux has-session -t "$SES_NAME" 2>/dev/null; then
    logv "creating tmux session $SES_NAME"
    tmux new-session -d -s "$SES_NAME" -c "$WT_DIR"
    tmux set-option -t "$SES_NAME" @wtx_repo_id "$REPO_ID"
  else
    ACTIONS="env:${ENV_STATUS}, pnpm:${PNPM_STATUS}, session:reattach"
  fi

  # inject env and banner
  tmux send-keys -t "$SES_NAME" "export WTX_UV_ENV=$(printf %q "$WTX_UV_ENV")" C-m
  tmux send-keys -t "$SES_NAME" 'if [ -n "$WTX_UV_ENV" ] && [ -d "$WTX_UV_ENV/bin" ]; then export PATH="$WTX_UV_ENV/bin:$PATH"; fi' C-m
  if [[ "${WTX_PROMPT:-0}" == "1" ]]; then
    tmux send-keys -t "$SES_NAME" "PS1='[wtx:$(printf %q "$BRANCH_NAME")] '\$PS1" C-m
  fi
  banner_cmd=$(printf "printf 'wtx: repo=%%s branch=%%s parent=%%s from=%%s actions=[%%s]\\n' %q %q %q %q %q" \
    "$REPO_BASENAME" "$BRANCH_NAME" "$PARENT_LABEL" "$FROM_REF" "$ACTIONS")
  tmux send-keys -t "$SES_NAME" "$banner_cmd" C-m
  tmux set-option -t "$SES_NAME" @wtx_ready 1

  # attach/switch
  if [[ -z "${NO_OPEN:-}" ]]; then
    if [[ -n "${TMUX:-}" ]]; then tmux switch-client -t "$SES_NAME"; else tmux attach -t "$SES_NAME"; fi
  else
    attach_hint
  fi

elif [[ "$MUX" == "screen" ]]; then
  need screen || die "screen not found"
  if ! screen -ls 2>/dev/null | awk '/\t/ {print $1}' | sed 's/^[0-9]*\.//' | grep -qx "$SES_NAME"; then
    logv "creating screen session $SES_NAME"
    screen -dmS "$SES_NAME" sh -c "cd '$(printf %q "$WT_DIR")'; exec \$SHELL"
  else
    ACTIONS="env:${ENV_STATUS}, pnpm:${PNPM_STATUS}, session:reattach"
  fi
  screen -S "$SES_NAME" -p 0 -X stuff "export WTX_UV_ENV=$(printf %q "$WTX_UV_ENV")$(printf '\r')"
  screen -S "$SES_NAME" -p 0 -X stuff "if [ -n \"\$WTX_UV_ENV\" ] && [ -d \"\$WTX_UV_ENV/bin\" ]; then export PATH=\"\$WTX_UV_ENV/bin:\$PATH\"; fi$(printf '\r')"
  if [[ "${WTX_PROMPT:-0}" == "1" ]]; then
    screen -S "$SES_NAME" -p 0 -X stuff "PS1='[wtx:$(printf %q "$BRANCH_NAME")] '\$PS1$(printf '\r')"
  fi
  # banner
  banner_cmd=$(printf "printf 'wtx: repo=%%s branch=%%s parent=%%s from=%%s actions=[%%s]\\n' %q %q %q %q %q" \
    "$REPO_BASENAME" "$BRANCH_NAME" "$PARENT_LABEL" "$FROM_REF" "$ACTIONS")
  screen -S "$SES_NAME" -p 0 -X stuff "$banner_cmd$(printf '\r')"

  if [[ -z "${NO_OPEN:-}" ]]; then
    screen -r "$SES_NAME"
  else
    attach_hint
  fi
fi

# -------- raw keystrokes (-c) --------
if [[ -n "$CMD" ]]; then
  if [[ "$MUX" == "tmux" ]]; then
    tmux send-keys -t "$SES_NAME" "$CMD" C-m
  else
    screen -S "$SES_NAME" -p 0 -X stuff "$CMD$(printf '\r')"
  fi
fi

# -------- logging --------
logf="$WTX_GIT_DIR/logs/$(date +%F).log"
tmp=$(mktemp)
printf '%s %s actions=[%s]\n' "$(date -Iseconds)" "$BRANCH_NAME" "$ACTIONS" >>"$tmp"
cat "$tmp" >>"$logf" && rm -f "$tmp"