#!/usr/bin/env bash
set -euo pipefail

# wtx — minimal worktree + tmux orchestrator for coding agents

# -----------------------------------------------------------------------------
# Configuration (env overrides)
# -----------------------------------------------------------------------------
WTX_CONTAINER_DEFAULT="${WTX_CONTAINER_DEFAULT:-}"   # overrides worktree parent dir
WTX_MESSAGING_POLICY="${WTX_MESSAGING_POLICY:-all}"  # parent,children,all
WTX_OSA_OPEN="${WTX_OSA_OPEN:-1}"                     # 1 to auto-launch macOS Terminal via osascript

# Absolute path to this script for use in git hooks
WTX_SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------
die(){ echo "wtx: $*" >&2; exit 1; }
is_macos(){ [[ "$(uname -s)" == "Darwin" ]]; }
has(){ command -v "$1" >/dev/null 2>&1; }
ensure_tools(){ has git || die "git not found"; has tmux || die "tmux not found"; }
ensure_repo(){ git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "run inside a git repo"; }
repo_root(){ git rev-parse --show-toplevel; }
repo_name(){
  local common root
  common=$(git rev-parse --git-common-dir)
  root=$(cd "$common/.." && pwd)
  basename "$root"
}
repo_git(){ git rev-parse --git-path .; }
container_dir(){
  local root="$(repo_root)"
  if [[ -n "$WTX_CONTAINER_DEFAULT" ]]; then
    printf '%s\n' "$WTX_CONTAINER_DEFAULT"
  else
    local parent
    parent="$(cd "$root/.." && pwd)"
    printf '%s\n' "$parent/$(repo_name).worktrees"
  fi
}
ensure_container(){ local dir; dir="$(container_dir)"; mkdir -p "$dir"; }
safe_slug(){
  local s="$1"
  s="${s// /-}"
  s="${s//_/-}"
  s="$(printf '%s' "$s" | tr '[:upper:]' '[:lower:]')"
  printf '%s\n' "$s" | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g'
}
counter_file(){ git rev-parse --git-path wtx.counter; }
next_counter(){
  local file; file="$(counter_file)"
  local n=1
  if [[ -f "$file" ]]; then
    n=$(<"$file")
    n=$((10#$n + 1))
  fi
  printf '%03d' "$n" >"$file"
  printf '%03d' "$n"
}
session_name_for(){
  local branch="$1"
  local name
  name="$(repo_name)-$branch"
  name="${name//[^A-Za-z0-9._-]/-}"
  printf '%s\n' "$name"
}
tmux_has(){ tmux has-session -t "$1" >/dev/null 2>&1; }
parents_desc_key(){ printf 'branch.%s.description\n' "$1"; }
set_branch_description(){
  local branch="$1" parent="$2"
  local desc="parent=$parent"
  git config "$(parents_desc_key "$branch")" "$desc"
}
get_branch_parent(){
  local branch="$1" desc
  desc=$(git config --get "$(parents_desc_key "$branch")" 2>/dev/null || true)
  [[ -z "$desc" ]] && return 1
  desc="${desc#parent=}"
  printf '%s\n' "$desc"
}
children_of(){
  local parent="$1" br
  while IFS= read -r br; do
    local p
    p=$(get_branch_parent "$br" 2>/dev/null || true)
    [[ "$p" == "$parent" ]] && printf '%s\n' "$br"
  done < <(git for-each-ref --format='%(refname:short)' refs/heads)
}

worktree_path_for(){ printf '%s/%s\n' "$(container_dir)" "$1"; }
post_commit_hook_path(){ git -C "$1" rev-parse --git-path hooks/post-commit; }

link_shared_environment(){
  local root="$(repo_root)" wt="$1"
  if [[ -d "$root/.venv" && ! -e "$wt/.venv" ]]; then
    ln -s "$root/.venv" "$wt/.venv"
  fi
  if [[ -f "$root/.env" && ! -e "$wt/.env" ]]; then
    ln -s "$root/.env" "$wt/.env"
  fi
}

osascript_terminal_attach(){
  local session="$1"
  is_macos || return 0
  [[ "$WTX_OSA_OPEN" == "1" ]] || return 0
  local osa="$(command -v osascript 2>/dev/null || true)"
  if [[ -z "$osa" ]]; then
    if [[ -x /usr/bin/osascript ]]; then
      osa="/usr/bin/osascript"
    else
      return 0
    fi
  fi
  "$osa" <<APPLESCRIPT
tell application "Terminal"
  activate
  do script "tmux attach -t ${session}"
end tell
APPLESCRIPT
}

start_tmux_session(){
  local branch="$1" wt="$2";
  local session; session="$(session_name_for "$branch")"
  if ! tmux_has "$session"; then
    local bootstrap
    bootstrap="cd \"$wt\"; "
    bootstrap+="if [ -d .venv/bin ]; then source .venv/bin/activate; fi; "
    bootstrap+="if command -v pnpm >/dev/null 2>&1 && { [ -f pnpm-lock.yaml ] || [ -f package.json ]; }; then pnpm install; fi; "
    bootstrap+="exec \$SHELL -l"
    tmux new-session -d -s "$session" -c "$wt" "bash -lc '$bootstrap'"
  fi
  tmux set-environment -t "$session" WTX_BRANCH "$branch" || true
  tmux set-environment -t "$session" WTX_PARENT "$(get_branch_parent "$branch" 2>/dev/null || echo '')" || true
}

send_startup_command(){
  local branch="$1" cmd="$2"
  [[ -z "$cmd" ]] && return 0
  local session; session="$(session_name_for "$branch")"
  tmux_has "$session" || return 0
  tmux send-keys -t "$session" -- "$cmd" Enter
}

install_post_commit_hook(){
  local wt="$1"
  local hook; hook="$(post_commit_hook_path "$wt")"
  mkdir -p "$(dirname "$hook")"
  cat >"$hook" <<HOOK
#!/bin/sh
"$WTX_SCRIPT_PATH" message
HOOK
  chmod +x "$hook"
}

print_create_result(){
  local branch="$1" parent="$2" path="$3" session="$4"
  printf 'created branch=%s parent=%s worktree=%s session=%s\n' "$branch" "$parent" "$path" "$session"
}

resolve_parent_branch(){
  local specified="$1"
  if [[ -n "$specified" ]]; then
    printf '%s\n' "$specified"
    return 0
  fi
  local current
  current=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  if [[ -n "$current" ]]; then
    printf '%s\n' "$current"
    return 0
  fi
  die "cannot determine parent branch (detached HEAD without --parent)"
}

next_branch_name(){
  local parent="$1" requested="$2"
  if [[ -n "$requested" ]]; then
    printf '%s\n' "$(safe_slug "$requested")"
    return 0
  fi
  local slug="$(safe_slug "$parent")"
  local num="$(next_counter)"
  printf '%s-%s\n' "$slug" "$num"
}

create_branch(){
  ensure_tools; ensure_repo
  local parent="" name="" command=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p|--parent)
        parent="$2"; shift 2;;
      -c|--command)
        command="$2"; shift 2;;
      --)
        shift; break;;
      -*)
        die "unknown option: $1";;
      *)
        if [[ -n "$name" ]]; then die "multiple names provided"; fi
        name="$1"; shift;;
    esac
  done
  if [[ $# -gt 0 ]]; then
    if [[ -n "$name" ]]; then die "unexpected extra arguments"; fi
    name="$1"; shift
  fi

  parent="$(resolve_parent_branch "$parent")"
  local branch
  branch="$(next_branch_name "$parent" "$name")"
  [[ -n "$branch" ]] || die "branch name empty"
  [[ "$branch" =~ ^[A-Za-z0-9._/-]+$ ]] || die "branch name contains invalid characters"
  git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null && die "branch '$branch' already exists"

  ensure_container
  local wt; wt="$(worktree_path_for "$branch")"
  git worktree add -b "$branch" "$wt" "$parent" >/dev/null
  set_branch_description "$branch" "$parent"
  link_shared_environment "$wt"
  install_post_commit_hook "$wt"
  local session
  session="$(session_name_for "$branch")"
  local new_session=0
  if ! tmux_has "$session"; then
    new_session=1
  fi
  start_tmux_session "$branch" "$wt"
  if [[ "$new_session" -eq 1 ]]; then
    osascript_terminal_attach "$session"
  fi
  send_startup_command "$branch" "$command"
  print_create_result "$branch" "$parent" "$wt" "$session"
}

list_worktrees(){
  ensure_repo
  printf '%-25s %-20s %s\n' "BRANCH" "PARENT" "WORKTREE"
  git worktree list --porcelain | awk '
    /^worktree /{wt=$2}
    /^branch /{
      ref=$2
      short=ref
      if (ref ~ /^refs\/heads\//) {
        short=substr(ref,12)
      }
    }
    /^$/ {
      branch=short
      ref=""; short=""
      parent=""
      cmd="git config --get branch." branch ".description"
      cmd | getline desc
      close(cmd)
      if (desc ~ /^parent=/) {
        parent=substr(desc,8)
      }
      printf("%-25s %-20s %s\n", branch, parent, wt)
      wt=""
    }
  '
}

policy_tokens(){
  local policy="$1" token
  IFS=',' read -r -a tokens <<<"$policy"
  for token in "${tokens[@]}"; do
    case "$token" in
      all) echo parent; echo children; return;;
      parent|parents) echo parent;;
      child|children) echo children;;
    esac
  done
}

print_to_session(){
  local session="$1" payload="$2"
  tmux send-keys -t "$session" -- "cat <<'WTXMSG'" Enter "$payload" Enter "WTXMSG" Enter
}

deliver_message(){
  local branch="$1" target="$2" msg="$3" session
  session="$(session_name_for "$target")"
  if tmux_has "$session"; then
    print_to_session "$session" "$msg"
  fi
}

cmd_message(){
  ensure_tools; ensure_repo
  local branch
  branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  [[ -n "$branch" ]] || die "wtx message requires a branch checkout"
  local parent
  parent=$(get_branch_parent "$branch" 2>/dev/null || true)
  local commit hash subject
  hash=$(git rev-parse --short HEAD)
  subject=$(git log -1 --pretty=%s 2>/dev/null || echo "(no message)")
  local msg
  msg="# [wtx from ${branch}]: new git commit with message: ${subject}. To integrate these changes, run: git merge ${hash}"

  local sent=0 target
  local policy_targets=()
  while IFS= read -r target; do policy_targets+=("$target"); done < <(policy_tokens "$WTX_MESSAGING_POLICY")
  if [[ ${#policy_targets[@]} -eq 0 ]]; then
    policy_targets=(parent children)
  fi

  for token in "${policy_targets[@]}"; do
    case "$token" in
      parent)
        if [[ -n "$parent" && "$parent" != "$branch" ]]; then
          deliver_message "$branch" "$parent" "$msg" && sent=1
        fi
        ;;
      children)
        while IFS= read -r child; do
          deliver_message "$branch" "$child" "$msg" && sent=1
        done < <(children_of "$branch")
        ;;
    esac
  done
  if [[ "$sent" -eq 0 ]]; then
    echo "no messaging targets" >&2
  fi
}

gc_empty_dirs(){
  local container="$(container_dir)"
  [[ -d "$container" ]] || return 0
  local active="$(mktemp)"
  local active_branches="$(mktemp)"
  local active_sessions="$(mktemp)"
  git worktree list --porcelain | awk '
    /^worktree /{print $2 > path}
    /^branch /{
      ref=$2
      if (ref ~ /^refs\/heads\//) {
        ref=substr(ref,12)
      }
      print ref > branch
    }
  ' path="$active" branch="$active_branches"
  while IFS= read -r branch; do
    [[ -n "$branch" ]] || continue
    session_name_for "$branch" >>"$active_sessions"
  done <"$active_branches"
  local dir
  shopt -s nullglob
  for dir in "$container"/*; do
    [[ -d "$dir" ]] || continue
    if ! grep -Fxq "$(cd "$dir" && pwd)" "$active"; then
      local branch; branch="$(basename "$dir")"
      rm -rf "$dir"
      local session="$(session_name_for "$branch")"
      tmux kill-session -t "$session" >/dev/null 2>&1 || true
      printf 'pruned %s\n' "$branch"
    fi
  done
  shopt -u nullglob
  if tmux list-sessions -F '#{session_name}' >/dev/null 2>&1; then
    local session_list
    session_list=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)
    if [[ -n "$session_list" ]]; then
      while IFS= read -r name; do
        [[ "$name" == $(repo_name)-* ]] || continue
        if ! grep -Fxq "$name" "$active_sessions"; then
          tmux kill-session -t "$name" >/dev/null 2>&1 || true
        fi
      done <<<"$session_list"
    fi
  fi
  rm -f "$active" "$active_branches" "$active_sessions"
}

cmd_prune(){
  ensure_tools; ensure_repo
  git worktree prune >/dev/null
  gc_empty_dirs
}

usage(){
  cat <<'USAGE'
wtx — minimal agent workflow helper

Usage:
  wtx create [NAME] [-p|--parent BRANCH] [-c|--command "..."]
  wtx message
  wtx list
  wtx prune

Environment:
  WTX_CONTAINER_DEFAULT  Override worktree parent directory
  WTX_MESSAGING_POLICY   Target policy for `wtx message` (parent, children, all)
  WTX_OSA_OPEN           Auto-launch macOS Terminal when creating sessions (default 1)
USAGE
}

main(){
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    create) create_branch "$@";;
    message) cmd_message;;
    list) list_worktrees;;
    prune) cmd_prune;;
    ""|help|-h|--help) usage;;
    *) die "unknown subcommand: $cmd";;
  esac
}

main "$@"
