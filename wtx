#!/usr/bin/env bash
# wtx — worktree + tmux/screen launcher (macOS Bash 3.2 compatible)
# Usage:
#   wtx [NAME] [-c CMD] [--from REF] [--mux auto|tmux|screen] [--no-open]
# Env:
#   WTX_GIT_DIR (default: .git/wtx) | WTX_UV_ENV (default: $HOME/.wtx/uv-shared)
#   WTX_MESSAGING_POLICY (unused placeholder) | WTX_PROMPT=1 to prefix PS1
# Notes:
#   - Prints a single-line banner in the first pane
#   - Sends raw keystrokes if -c is provided (no eval)
#   - Compatible with ancient macOS bash (3.2), no flock, no arrays required

set -euo pipefail
IFS=$'\n\t'

need() { command -v "$1" >/dev/null 2>&1; }

# -------- args --------
NAME=""
CMD=""
FROM_REF="HEAD"
MUX="${MUX:-auto}"
NO_OPEN=0
VERBOSE=0

print_help() {
  cat <<EOF
wtx — create/reuse a git worktree and open a tmux/screen session with a one-line banner.

Usage: wtx [NAME] [-c CMD] [--from REF] [--mux auto|tmux|screen] [--no-open] [--verbose]
Examples:
  wtx                       # auto-name branch wtx/<parent>-NN, create worktree + session
  wtx feature-xyz -c 'pytest -q'   # send raw keystrokes after session is ready
  wtx --mux screen          # use GNU screen if you prefer

Flags:
  -c CMD         Send raw keystrokes to pane (exactly, then Enter)
  --from REF     Use REF as starting point (default: HEAD)
  --mux MODE     auto|tmux|screen   (default: auto)
  --no-open      Do not attach/switch to the session; only print attach command
  --verbose      Print extra diagnostics
  -h|--help      This help
EOF
}

# manual arg parse for long flags (bash 3.2 getopts has no long support)
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help) print_help; exit 0 ;;
    -c) shift; CMD="${1:-}"; [ -z "${CMD}" ] && { echo "Missing argument for -c"; exit 2; } ;;
    --from) shift; FROM_REF="${1:-HEAD}" ;;
    --mux) shift; MUX="${1:-auto}" ;;
    --no-open) NO_OPEN=1 ;;
    --verbose) VERBOSE=1 ;;
    --*) echo "Unknown option: $1"; exit 2 ;;
    *) if [ -z "$NAME" ]; then NAME="$1"; else echo "Unexpected arg: $1"; exit 2; fi ;;
  esac
  shift
done

# -------- repo info --------
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || { echo "Not inside a git repo"; exit 1; }
GIT_DIR=$(git rev-parse --git-dir)
REPO_BASENAME=$(basename "$REPO_ROOT")

# -------- defaults & dirs --------
WTX_GIT_DIR=${WTX_GIT_DIR:-"$GIT_DIR/wtx"}
WTX_UV_ENV=${WTX_UV_ENV:-"$HOME/.wtx/uv-shared"}
WTX_MESSAGING_POLICY=${WTX_MESSAGING_POLICY:-parent,children}
WTX_PROMPT=${WTX_PROMPT:-0}

mkdir -p "$WTX_GIT_DIR"/logs "$WTX_GIT_DIR"/locks "$WTX_GIT_DIR"/state
chmod 700 "$WTX_GIT_DIR" || true

# -------- mux select --------
if [ "$MUX" = "auto" ]; then
  if need tmux; then MUX=tmux
  elif need screen; then MUX=screen
  else echo "Need tmux or screen installed."; exit 2; fi
fi
[ $VERBOSE -eq 1 ] && echo "[wtx] mux=$MUX"

# -------- parent & branch naming --------
PARENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo detached)
PARENT_SHA=$(git rev-parse "$FROM_REF")
PARENT_SHORT=$(git rev-parse --short "$PARENT_SHA")

# portable lock (no flock)
lockdir="$WTX_GIT_DIR/locks/${PARENT_BRANCH}.lockdir"
while ! mkdir "$lockdir" 2>/dev/null; do sleep 0.05; done
cleanup_lock() { rmdir "$lockdir" 2>/dev/null || true; }
trap cleanup_lock EXIT

if [ -z "$NAME" ]; then
  existing=$(git for-each-ref --format='%(refname:short)' "refs/heads/wtx/${PARENT_BRANCH}-*" 2>/dev/null | \
             grep -E "^wtx/${PARENT_BRANCH}-[0-9]+$" || true)
  last=$(echo "$existing" | sed -E 's/.*-([0-9]+)$/\1/' | sort -n | tail -1 || true)
  if [ -z "$last" ]; then NN=1; else NN=$(( last + 1 )); fi
  BRANCH_NAME="wtx/${PARENT_BRANCH}-${NN}"
else
  BRANCH_NAME="$NAME"
fi

WORKTREE_NAME=$(printf %s "$BRANCH_NAME" | tr '/:' '__')

# -------- ensure branch exists --------
if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
  git branch "$BRANCH_NAME" "$FROM_REF" 2>/dev/null || git branch --no-track "$BRANCH_NAME" "$FROM_REF"
fi

# description (safe)
desc="wtx: created_by=wtx
wtx: parent_branch=${PARENT_BRANCH}
wtx: from_ref=${FROM_REF}"
git config "branch.$BRANCH_NAME.description" "$desc" || true

# tiny state JSON
state="$WTX_GIT_DIR/state/$WORKTREE_NAME.json"
tmp=$(mktemp)
printf '{"created_by":"wtx","parent_branch":"%s","from_ref":"%s"}\n' "$PARENT_BRANCH" "$FROM_REF" >"$tmp"
mv "$tmp" "$state"

# -------- worktree ensure --------
WORKTREE_ROOT="$(dirname "$REPO_ROOT")/${REPO_BASENAME}.worktrees"
WT_DIR="$WORKTREE_ROOT/$WORKTREE_NAME"
mkdir -p "$WORKTREE_ROOT"

# repair zombies if any
if [ -d "$WT_DIR" ] && ! git -C "$REPO_ROOT" worktree list --porcelain | grep -q "worktree $WT_DIR"; then
  git -C "$REPO_ROOT" worktree prune || true
fi

if ! git -C "$REPO_ROOT" worktree list --porcelain | grep -q "worktree $WT_DIR"; then
  git -C "$REPO_ROOT" worktree add "$WT_DIR" "$BRANCH_NAME"
fi

# -------- shared uv env (optional) --------
ENV_ACTION="none"
if need uv; then
  if [ ! -d "$WTX_UV_ENV" ]; then
    uv venv "$WTX_UV_ENV"
  fi
  ENV_ACTION="linked"
fi

# -------- pnpm install (optional) --------
PNPM_STATUS="none"
if [ -f "$WT_DIR/package.json" ] && need pnpm; then
  PNPM_STAMP="$WT_DIR/.wtx_pnpm_stamp"
  if [ ! -d "$WT_DIR/node_modules" ] || { [ -f "$WT_DIR/pnpm-lock.yaml" ] && [ "$WT_DIR/pnpm-lock.yaml" -nt "$PNPM_STAMP" ]; }; then
    ( cd "$WT_DIR" && pnpm install --frozen-lockfile )
    tmp=$(mktemp) && date +%s >"$tmp" && mv "$tmp" "$PNPM_STAMP"
    PNPM_STATUS="installed"
  else
    PNPM_STATUS="skipped"
  fi
fi

# -------- session naming & repo id --------
ses_repo=$(printf %s "$REPO_BASENAME" | tr '/:' '__')
ses_branch=$(printf %s "$BRANCH_NAME" | tr '/:' '__')
SES_NAME="wtx.${ses_repo}.${ses_branch}"

if need sha1sum; then
  REPO_ID=$(printf %s "$REPO_ROOT" | sha1sum | cut -c1-8)
else
  REPO_ID=$(printf %s "$REPO_ROOT" | shasum -a 1 | awk '{print $1}' | cut -c1-8)
fi

# -------- banner values --------
if [ "$PARENT_BRANCH" = "detached" ]; then
  PARENT_LABEL="detached@${PARENT_SHORT}"
else
  PARENT_LABEL="$PARENT_BRANCH"
fi
ACTIONS="env:${ENV_ACTION}, pnpm:${PNPM_STATUS}"

# -------- tmux path --------
attach_cmd=""
if [ "$MUX" = "tmux" ]; then
  if ! tmux has-session -t "$SES_NAME" 2>/dev/null; then
    tmux new-session -d -s "$SES_NAME" -c "$WT_DIR"
    tmux set-option -t "$SES_NAME" @wtx_repo_id "$REPO_ID"
    session_action="created"
  else
    session_action="reattach"
  fi

  # build safe exports for inside-pane env (use printf %q to escape)
  q() { printf %q "$1"; }
  exp_line="WTX_UV_ENV=$(q "$WTX_UV_ENV") REPO_BASENAME=$(q "$REPO_BASENAME") BRANCH_NAME=$(q "$BRANCH_NAME") PARENT_LABEL=$(q "$PARENT_LABEL") FROM_REF=$(q "$FROM_REF") ACTIONS=$(q "$ACTIONS, session:${session_action}") WTX_PROMPT=$(q "$WTX_PROMPT")"
  # minimal init script once per branch (static, uses env above)
  INIT="$WTX_GIT_DIR/state/wtx-init.sh"
  if [ ! -f "$INIT" ]; then
    cat >"$INIT" <<'EOF'
# wtx init (sourced inside tmux pane); relies on env vars set just before sourcing.
# Add uv bin to PATH if present
if [ -n "${WTX_UV_ENV:-}" ] && [ -d "$WTX_UV_ENV/bin" ]; then
  PATH="$WTX_UV_ENV/bin:$PATH"; export PATH
fi
# Optional prompt prefix
if [ "${WTX_PROMPT:-0}" = "1" ]; then
  PS1="[wtx:${BRANCH_NAME}] $PS1"
fi
# One-line banner (purely informational)
printf 'wtx: repo=%s branch=%s parent=%s from=%s actions=[%s]\n' \
  "${REPO_BASENAME:-?}" "${BRANCH_NAME:-?}" "${PARENT_LABEL:-?}" "${FROM_REF:-?}" "${ACTIONS:-?}"
# Mark ready on current session
tmux set-option -t "$(tmux display-message -p '#S')" @wtx_ready 1 2>/dev/null || true
EOF
  fi

  # Source init inside pane
  tmux send-keys -t "$SES_NAME" "$exp_line . $(q "$INIT")" C-m

  # Raw keystrokes
  if [ -n "$CMD" ]; then
    tmux send-keys -t "$SES_NAME" "$CMD" C-m
  fi

  # Attach / switch
  if [ $NO_OPEN -eq 0 ]; then
    if [ -n "${TMUX:-}" ]; then
      tmux switch-client -t "$SES_NAME"
    else
      tmux attach -t "$SES_NAME"
    fi
  else
    attach_cmd="tmux attach -t '$SES_NAME'"
  fi
fi

# -------- screen path --------
if [ "$MUX" = "screen" ]; then
  if ! screen -ls | grep -q "[[:space:]]${SES_NAME}[[:space:]]"; then
    screen -dmS "$SES_NAME" sh -c "cd '$(printf %q "$WT_DIR")'; exec \$SHELL"
    session_action="created"
  else
    session_action="reattach"
  fi
  # exports within screen (ensure PATH prepend happens at runtime)
  screen -S "$SES_NAME" -p 0 -X stuff "export WTX_UV_ENV='$(printf %q "$WTX_UV_ENV")'$(printf '\r')"
  screen -S "$SES_NAME" -p 0 -X stuff "export PATH='$(printf %q "$WTX_UV_ENV")/bin:\$PATH'$(printf '\r')"
  # banner
  banner=$(printf "printf 'wtx: repo=%%s branch=%%s parent=%%s from=%%s actions=[%%s]\\n' %q %q %q %q %q" \
           "$REPO_BASENAME" "$BRANCH_NAME" "$PARENT_LABEL" "$FROM_REF" "env:${ENV_ACTION}, pnpm:${PNPM_STATUS}, session:${session_action}")
  screen -S "$SES_NAME" -p 0 -X stuff "$banner$(printf '\r')"
  # raw keystrokes
  if [ -n "$CMD" ]; then
    screen -S "$SES_NAME" -p 0 -X stuff "$CMD$(printf '\r')"
  fi
  # attach
  if [ $NO_OPEN -eq 0 ]; then
    screen -r "$SES_NAME"
  else
    attach_cmd="screen -r '$SES_NAME'"
  fi
fi

# -------- logging --------
logf="$WTX_GIT_DIR/logs/$(date +%F).log"
tmp=$(mktemp)
printf '%s %s actions=[%s]\n' "$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S%z')" "$BRANCH_NAME" "env:${ENV_ACTION}, pnpm:${PNPM_STATUS}" >>"$tmp"
cat "$tmp" >>"$logf" || true
rm -f "$tmp" || true

# -------- final message if not attached --------
if [ -n "$attach_cmd" ]; then
  echo "[wtx] Attach with: $attach_cmd"
fi